{
  "name": "memoizee",
  "version": "0.1.1",
  "description": "Complete memoize/cache solution. Works with any type and length of function arguments",
  "main": "lib/memoize",
  "scripts": {
    "test": "node node_modules/tad/bin/tad lib"
  },
  "repository": {
    "type": "git",
    "url": "git://github.com/medikoo/memoize.git"
  },
  "keywords": [
    "memoize",
    "memoizer",
    "cache",
    "memoization",
    "memo",
    "memcached",
    "hashing.",
    "storage",
    "caching",
    "memory",
    "gc",
    "weak",
    "garbage",
    "collector"
  ],
  "bugs": {
    "email": "medikoo+memoize@medikoo.com",
    "url": "https://github.com/medikoo/memoize/issues"
  },
  "engines": {
    "node": ">=0.4"
  },
  "dependencies": {
    "es5-ext": "0.9.x",
    "next-tick": "0.1.x"
  },
  "devDependencies": {
    "tad": "0.1.x"
  },
  "author": {
    "name": "Mariusz Nowak",
    "email": "medikoo+memoize@medikoo.com",
    "url": "http://www.medikoo.com/"
  },
  "license": "MIT",
  "readme": "# Memoize – Complete memoize solution for JavaScript\n\n_Originally derived from [es5-ext](https://github.com/medikoo/es5-ext) package._\n\nMemoization is best technique to save on memory or CPU cycles when we deal with repeated operations. For detailed insight see: http://en.wikipedia.org/wiki/Memoization\n\n## Features\n\n* Works with any type of function arguments – __no serialization is needed__\n* Works with [__any length of function arguments__](#arguments-length). Length can be set as fixed or dynamic.\n* One of the [__fastest__](https://github.com/medikoo/memoize/tree/master/benchmark) available solutions.\n* Support for [__asynchronous functions__](#memoizing-asynchronous-functions)\n* Optional [__primitive mode__](#primitive-mode) which assures fast performance when arguments are conversible to strings.\n* Can be configured [__for methods__](#memoizing-a-method) (when `this` counts in)\n* Cache can be cleared [manually](#manual-clean-up) or [after specified timeout](#expire-cache-after-given-period-of-time)\n* Cache size can be [limited](#limiting-cache-size)\n* Optionally [__accepts resolvers__](#resolvers) that normalize function arguments before passing them to underlying function.\n* Optional [__reference counter mode__](#reference-counter), that allows more sophisticated cache management\n* [__Profile tool__](#profiling--statistics) that provides valuable usage statistics\n* Covered by [__over 500 unit tests__](#tests-)\n\n## Usage\n\n```javascript\nvar memoize = require('memoizee');\n\nvar fn = function (one, two, three) { /* ... */ };\n\nmemoized = memoize(fn);\n\nmemoized('foo', 3, 'bar');\nmemoized('foo', 3, 'bar'); // Cache hit\n```\n\n## Installation\n### NPM\n\nIn your project path:\n\n\t$ npm install memoizee\n\n### Browser\n\nBrowser bundle can be easily created with help of [modules-webmake](https://github.com/medikoo/modules-webmake). Mind that it relies on some EcmaScript5 features, so for older browsers you need as well [es5-shim](https://github.com/kriskowal/es5-shim)\n\n## Configuration\n\nAll below options can be applied in any combination\n\n### Arguments length\n\nBy default fixed number of arguments that function take is assumed (it's read from function's  `length` property) this can be overridden:\n\n```javascript\nmemoized = memoize(fn, { length: 2 });\n\nmemoized('foo');            // Assumed: 'foo', undefined\nmemoized('foo', undefined); // Cache hit\n\nmemoized('foo', 3, {}); // Third argument is ignored (but passed to underlying function)\nmemoized('foo', 3, 13); // Cache hit\n```\n\nDynamic _length_ behavior can be forced by setting _length_ to `false`, that means memoize will work with any number of arguments.\n\n```javascript\nmemoized = memoize(fn, { length: false });\n\nmemoized('foo');\nmemoized('foo'); // Cache hit\nmemoized('foo', undefined);\nmemoized('foo', undefined); // Cache hit\n\nmemoized('foo', 3, {});\nmemoized('foo', 3, 13);\nmemoized('foo', 3, 13); // Cache hit\n```\n\n### Primitive mode\n\nIf we work with large result sets, or memoize hot functions, default mode may not perform as fast as we expect. In that case it's good to run memoization in _primitive_ mode. To provide fast access, results are saved in hash instead of an array. Generated hash ids are result of arguments to string convertion. __Mind that this mode will work correctly only if stringified arguments produce unique strings.__\n\n```javascript\nmemoized = memoize(fn, { primitive: true });\n\nmemoized('/path/one');\nmemoized('/path/one'); // Cache hit\n```\n\n### Resolvers\n\nWhen not working in _primitive_ mode but expecting arguments of certain type it's good to coerce them before doing memoization. We can do that by passing additional resolvers array:\n\n```javascript\nmemoized = memoize(fn, { length: 2, resolvers: [String, Boolean] });\n\nmemoized(12, [1,2,3].length);\nmemoized(\"12\", true); // Cache hit\nmemoized({ toString: function () { return \"12\"; } }, {}); // Cache hit\n```\n\n### Memoizing asynchronous functions\n\nWith _async_ option we indicate that we memoize asynchronous function.  \nOperations that result with an error are not cached.\n\n```javascript\nafn = function (a, b, cb) {\n  setTimeout(function () {\n    cb(null, a + b);\n  }, 200);\n};\nmemoized = memoize(afn, { async: true });\n\nmemoized(3, 7, function (err, res) {\n  memoized(3, 7, function (err, res) {\n    // Cache hit\n  });\n});\n\nmemoized(3, 7, function (err, res) {\n  // Cache hit\n});\n```\n\n### Memoizing a method\n\nWhen we are defining a prototype, we may want to define method that will memoize it's results in relation to each instance. Basic way to obtain that would be:\n\n```javascript\nvar Foo = function () {\n  this.bar = memoize(this.bar.bind(this));\n  // ... constructor logic\n};\nFoo.prototype.bar = function () {\n  // ... method logic\n};\n```\n\nWith _method_ option we can configure memoization directly on prototype:\n\n```javascript\nvar Foo = function () {\n  // ... constructor logic\n};\nFoo.prototype.bar = memoize(function () {\n  // ... method logic\n}, { method: 'bar' });\n```\n\nAdditionally we may provide descriptor which would be used for defining method on instance object:\n\n```javascript\nvar Foo = function () {\n  // ... constructor logic\n};\nFoo.prototype.bar = memoize(function () {\n  // ... method logic\n}, { method: { name: 'bar', descriptor: { configurable: true } } });\n```\n\n### Cache handling\n\n#### Manual clean up:\n\nClear data for particular call.\n\n```javascript\nmemoized.clear('foo', true);\n```\n\nArguments passed to `clear` are treated with same rules as input arguments passed to function\n\nClear all cached data:\n\n```javascript\nmemoized.clearAll();\n```\n\n#### Expire cache after given period of time\n\nWith _maxAge_ option we can ensure that cache for given call is cleared after predefined period of time\n\n```javascript\nmemoized = memoize(fn, { maxAge: 1000 });\n\nmemoized('foo', 3);\nmemoized('foo', 3); // Cache hit\nsetTimeout(function () {\n  memoized('foo', 3); // No longer in cache, re-executed\n  memoized('foo', 3); // Cache hit\n}, 2000);\n```\n\n#### Reference counter\n\nWe can track number of references returned from cache, and manually clear them. When last reference is cleared, cache is purged automatically:\n\n```javascript\nmemoized = memoize(fn, { refCounter: true });\n\nmemoized('foo', 3);          // refs: 1\nmemoized('foo', 3);          // Cache hit, refs: 2\nmemoized('foo', 3);          // Cache hit, refs: 3\nmemoized.clearRef('foo', 3); // refs: 2\nmemoized.clearRef('foo', 3); // refs: 1\nmemoized.clearRef('foo', 3); // refs: 0, Cache purged for 'foo', 3\nmemoized('foo', 3);          // Re-executed, refs: 1\n```\n\n#### Limiting cache size\n\nWith _max_ option you can limit cache size. It works on first-in/first-out basis.\n\n```javascript\nmemoized = memoize(fn, { max: 2 });\n\nmemoized('foo', 3);\nmemoized('bar', 7);\nmemoized('foo', 3);    // Cache hit\nmemoized('bar', 7);    // Cache hit\nmemoized('lorem', 11); // Cache cleared for 'foo', 3\nmemoized('bar', 7);    // Cache hit\nmemoized('foo', 3);    // Re-executed, Cache cleared for 'bar', 7\nmemoized('lorem', 11); // Cache hit\nmemoized('foo', 3);    // Cache hit\nmemoized('bar', 7);    // Re-executed, Cache cleared for 'lorem', 11\n```\n\n#### Registering dispose callback\nYou can register callback that is called on each value being removed from cache:\n\n```javascript\nmemoized = memoize(fn, { dispose: function (value) { /*…*/ } });\n\nvar foo3 = memoized('foo', 3);\nvar bar7 = memoized('bar', 7);\nmemoized.clear('foo', 3); // Dispose called with foo3 value\nmemoized.clear('bar', 7); // Dispose called with bar7 value\n```\n\n## Profiling & Statistics\n\nIf you want to make sure how much you benefit from memoization or just check if memoization works as expected, loading profile module will give access to all valuable information.\n\n__Module needs to be imported before any memoization (that we want to track) is configured. Mind also that running profile module affects performance, it's best not to use it in production environment__\n\n```javascript\nvar memProfile = require('memoizee/lib/profile');\n```\n\nAccess statistics at any time:\n\n```javascript\nmemProfile.statistics;         // Statistcs accessible for programmatical use\nconsole.log(memProfile.log()); // Output statistics data in readable form\n```\n\nExample console output:\n\n```\n------------------------------------------------------------\nMemoize statistics:\n\n Init  Cache  %Cache  Avg init time  Source location\n11604  35682   75.46         0.000s  (all)\n 2112  19901   90.41         0.000s  at /Users/medikoo/Projects/_packages/next/lib/fs/is-ignored.js:276:12\n 2108   9087   81.17         0.001s  at /Users/medikoo/Projects/_packages/next/lib/fs/is-ignored.js:293:10\n 6687   2772   29.31         0.000s  at /Users/medikoo/Projects/_packages/next/lib/fs/watch.js:125:9\n  697   3922   84.91         0.000s  at /Users/medikoo/Projects/_packages/next/lib/fs/is-ignored.js:277:15\n------------------------------------------------------------\n```\n\n* _Init_ – Initial hits\n* _Cache_ – Cache hits\n* _%Cache_ – What's the percentage of cache hits (of all function calls)\n* _Avg init time_ – Average execution time of initial call\n* _Source location_ – Where in the source code given memoization was initialized\n\n## Tests [![Build Status](https://secure.travis-ci.org/medikoo/memoize.png?branch=master)](https://secure.travis-ci.org/medikoo/memoize)\n\n\t$ npm test\n",
  "_id": "memoizee@0.1.1",
  "dist": {
    "shasum": "676ea4f99fa3e12f11319a9c2a5cecf61a7c5199"
  },
  "_from": "memoizee@0.1.x"
}
